# Chapter 9. Debugging

# Shell Programs

We hope that we have convinced you that _bash_ can be
used as a serious UNIX programming environment. It
certainly has enough features, control structures, etc. But
another essential part of a programming environment is a
set of powerful, integrated _support tools_. For example,
there is a wide assortment of screen editors, compilers,
debuggers, profilers, cross-referencers, etc., for languages
like C and C++. If you program in one of these
languages, you probably take such tools for granted, and
you would undoubtedly cringe at the thought of having to
develop code with, say, the _ed_ editor and the _adb_
machine-language debugger.

But what about programming support tools for _bash_? Of
course, you can use any editor you like, including _vi_ and
_emacs_. And because the shell is an interpreted language,
you don't need a compiler.[1]But there are no other tools
available.

This chapter looks at some useful features that you can
use to debug shell programs. We'll look at how you can
utilize them in the first part of this chapter. We'll then
look at some powerful new features of _bash_ , not present
in most Bourne shell workalikes, which will help in
building a shell script debugging tool. At the end of the


chapter, we'll show step by step how to build a debugger
for _bash_. The debugger, called _bashdb_ , is a basic yet
functional program that will not only serve as an
extended example of various shell programming
techniques, but will also provide you with a useful tool
for examining the workings of your own shell scripts.

# Basic Debugging Aids

What sort of functionality do you need to debug a
program? At the most empirical level, you need a way of
determining _what_ is causing your program to behave
badly, and _where_ the problem is in the code. You usually
start with an obvious _what_ (such as an error message,
inappropriate output, infinite loop, etc.), try to work
backwards until you find a _what_ that is closer to the
actual problem (e.g., a variable with a bad value, a bad
option to a command), and eventually arrive at the exact
_where_ in your program. Then you can worry about _how_ to
fix it.

Notice that these steps represent a process of starting with
obvious information and ending up with often obscure
facts gleaned through deduction and intuition. Debugging
aids make it easier to deduce and intuit by providing
relevant information easily or even automatically,
preferably without modifying your code.

The simplest debugging aid (for any language) is the
output statement, **echo** , in the shell's case. Indeed,


old-time programmers debugged their FORTRAN code
by inserting **WRITE** cards into their decks. You can
debug by putting lots of **echo** statements in your code
(and removing them later), but you will have to spend lots
of time narrowing down not only _what_ exact information
you want but also _where_ you need to see it. You will also
probably have to wade through lots and lots of output to
find the information you really want.

## Set Options

Luckily, the shell has a few basic features that give you
debugging functionality beyond that of **echo**. The most
basic of these are options to the **set -o** command (as
covered inChapter 3). These options can also be used on
the command line when running a script, asTable 9-1
shows.

**Table 9-1. Debugging options**

```
set -o
option
```
```
Command-line
option
Action
```
```
noexec -n
Don't run commands; check
for syntax errors only
```

```
set -o
option
```
```
Command-line
option
Action
```
```
verbose -v
Echo commands before
running them
```
```
xtrace -x
Echo commands after
command-line processing
```
The **verbose** option simply echoes (to standard error)
whatever input the shell gets. It is useful for finding the
exact point at which a script is bombing. For example,
assume your script looks like this:

```
alice
hatter
march
teatime
treacle
well
```
None of these commands is a standard UNIX program,
and each does its work silently. Say the script crashes
with a cryptic message like "segmentation violation."
This tells you nothing about which command caused the
error. If you type **bash -v** _scriptname_ , you might see this:


```
alice
hatter
march
segmentation violation
teatime
treacle
well
```
Now you know that **march** is the probable
culprit—though it is also possible that **march** bombed
because of something it expected **alice** or **hatter** to do
(e.g., create an input file) that they did incorrectly.

The **xtrace** option is more powerful: it echoes command
lines after they have been through parameter substitution,
command substitution, and the other steps of
command-line processing (as listed in Chapter 7). For
example:

```
.ps 8
$ set -o xtrace $ alice=girl + alice=girl
$ echo "$alice" + echo girl
girl
$ ls -l $(type -path vi) ++ type -path vi
+ ls -F -l /usr/bin/vi
lrwxrwxrwx 1 root root 5 Jul 26 20:59 /usr/bin/vi -> elvis*
$
```
As you can see, **xtrace** starts each line it prints with **+**
(each **+** representing a level of expansion). This is
actually customizable: it's the value of the built-in shell
variable **PS4**. So if you set **PS4** to " **xtrace—>** " (e.g., in
your _.bash_profile_ or _.bashrc_ ), then you'll get **xtrace**
listings that look like this:


```
.ps 8
$ ls -l $(type -path vi) xxtrace--> type -path vi
xtrace--> ls -l /usr/bin/vi
lrwxrwxrwx 1 root root 5 Jul 26 20:59 /usr/bin/vi -> elvis*
$
```
Notice that for multiple levels of expansion, only the first
character of **PS4** is printed. This makes the output more
readable.

An even better way of customizing **PS4** is to use a
built-in variable we haven't seen yet: **LINENO** , which
holds the number of the currently running line in a shell
script.[2] Put this line in your _.bash_profile_ or
environment file:

```
PS4='line $LINENO: '
```
We use the same technique as we did with **PS1** in
Chapter 3: using single quotes to postpone the evaluation
of the string until each time the shell prints the prompt.
This will print messages of the form **line** _N_ : in your trace
output. You could even include the name of the shell
script you're debugging in this prompt by using the
positional parameter **$0** :

```
PS4='$0 line $LINENO: '
```
As another example, say you are trying to track down a
bug in a script called **alice** that contains this code:

```
dbfmq=$1.fmq
...
fndrs=$(cut -f3 -d' ' $dfbmq)
```

You type **alice teatime** to run it in the normal way, and it
hangs. Then you type **bash -x alice teatime** , and you see
this:

```
+ dbfmq=teatime.fmq
...
+ + cut -f3 -d
```
It hangs again at this point. You notice that _cut_ doesn't
have a filename argument, which means that there must
be something wrong with the variable **dbfmq**. But it has
executed the assignment statement **dbfmq=teatime.fmq**
properly... ah- _hah_! You made a typo in the variable name
inside the command substitution construct.[3]You fix it,
and the script works properly.

The last option is **noexec** , which reads in the shell script
and checks for syntax errors, but doesn't execute
anything. It's worth using if your script is syntactically
complex (lots of loops, command blocks, string operators,
etc.) and the bug has side effects (like creating a large file
or hanging up the system).

You can turn on these options with **set -o** _option_ in your
shell scripts, and, as explained inChapter 3, turn them off
with **set +o** _option_. For example, if you're debugging a
chunk of code, you can precede it with **set -o xtrace** to
print out the executed commands, and end the chunk with
**set +o xtrace**.


Note, however, that once you have turned **noexec** on, you
won't be able to turn it off; a **set +o noexec** will never be
executed.


## Fake Signals

_Fake signals_ are more sophisticated set of debugging
aids. They can be used in **trap** statements to get the shell
to act under certain conditions. Recall from the previous
chapter that **trap** allows you to install some code that
runs when a particular signal is sent to your script.

Fake signals work in the same way, but they are
generated by the shell itself, as opposed to the other
signals which are generated externally. They represent
runtime events that are likely to be of interest to
debuggers—both human ones and software tools—and
can be treated just like real signals within shell scripts.
Table 9-2lists the four fake signals available in _bash_.

**Table 9-2. Fake signals**

```
Fake
signal
Sent when
```
```
EXIT The shell exits from script
```
```
ERR A command returning a non-zero exit status
```

```
Fake
signal
Sent when
```
```
DEBUG The shell has executed a statement[4]
```
#### RETURN

```
A shell function or a script executed with
the. or source builtins finishes executing[5]
```
```
[4]The DEBUG signal is not available in bash versions
prior to 2.0.
```
```
[5] The RETURN signal is not available in bash
versions prior to 3.0.
```
### EXIT

The EXIT trap, when set, will run its code whenever the
script within which it was set exits.[6]

Here's a simple example:

```
trap 'echo exiting from the script' EXIT
echo 'start of the script'
```
If you run this script, you will see this output:


```
start of the script
exiting from the script
```
In other words, the script starts by setting the trap for its
own exit, then prints a message. The script then exits,
which causes the shell to generate the signal EXIT, which
in turn runs the code **echo exiting from the script**.

An EXIT trap occurs no matter how the script
exits—whether normally (by finishing the last statement),
by an explicit **exit** or **return** statement, or by receiving a
"real" signal such as INT or TERM. Consider this inane
number-guessing program:

```
trap 'echo Thank you for playing!' EXIT
```
```
magicnum=$(($RANDOM%10+1))
echo 'Guess a number between 1 and 10:'
while read -p 'Guess: ' guess ; do
sleep 4
if [ "$guess" = $magicnum ]; then
echo 'Right!'
exit
fi
echo 'Wrong!'
done
```
This program picks a number between 1 and 10 by
getting a random number (the built-in variable
**RANDOM** ), extracting the last digit (the remainder when
divided by 10), and adding 1. Then it prompts you for a
guess, and after 4 seconds, it will tell you if you guessed
right.


If you did, the program will exit with the message,
"Thank you for playing!", i.e., it will run the EXIT trap
code. If you were wrong, it will prompt you again and
repeat the process until you get it right. If you get bored
with this little game and hit CTRL-C or CTRL-D while
waiting for it to tell you whether you were right, you will
also see the message.

The EXIT trap is especially useful when you want to print
out the values of variables at the point that your script
exits. For example, by printing the value of loop counter
variables, you can find the most appropriate places in a
complicated script, with many nested **for** loops, to enable
**xtrace** or place debug output.


### ERR

The fake signal ERR enables you to run code whenever a
command in the surrounding script or function exits with
non-zero status. Trap code for ERR can take advantage of
the built-in variable**?** , which holds the exit status of the
previous command. It survives the trap and is accessible
at the beginning of the trap-handling code.

A simple but effective use of this is to put the following
code into a script you want to debug:

```
function errtrap {
es=$?
echo "ERROR: Command exited with status $es."
}
trap errtrap ERR
```
The first line saves the nonzero exit status in the local
variable **es**.

For example, if the shell can't find a command, it returns
status 127. If you put the code in a script with a line of
gibberish (like "nhbdeuje"), the shell responds with:

```
scriptname: line N: nhbdeuje: command not found
ERROR: command exited with status 127.
```
N is the number of the line in the script that contains the
bad command. In this case, the shell prints the line
number as part of its own error-reporting mechanism,


since the error was a command that the shell could not
find. But if the nonzero exit status comes from another
program, the shell doesn't report the line number. For
example:

```
function errtrap {
es=$?
echo "ERROR: Command exited with status $es."
}
trap errtrap ERR
function bad {
return 17
}
bad
```
This only prints **ERROR: Command exited with status
17**.

It would obviously be an improvement to include the line
number in this error message. The built-in variable
LINENO exists, but if you use it inside a function, it
evaluates to the line number in the function, not in the
overall file. In other words, if you used $LINENO in the
**echo** statement in the **errtrap** routine, it would always
evaluate to 2.

To get around this problem, we simply pass $LINENO as
an argument to the trap handler, surrounding it in single
quotes so that it doesn't get evaluated until the fake signal
actually comes in:

```
function errtrap {
es=$?
echo "ERROR line $1: Command exited with status $es."
```

```
}
trap 'errtrap $LINENO' ERR
...
```
If you use this with the above example, the result is the
message **, ERROR line 12: Command exited with
status 17**. This is much more useful. We'll see a variation
on this technique shortly.

This simple code is actually not a bad all-purpose
debugging mechanism. It takes into account that a
nonzero exit status does not necessarily indicate an
undesirable condition or event: remember that every
control construct with a conditional ( **if** , **while** , etc.) uses a
nonzero exit status to mean "false." Accordingly, the shell
doesn't generate ERR traps when statements or
expressions in the "condition" parts of control structures
produce nonzero exit statuses. Also, an ERR trap is not
inherited by shell functions, command substitutions, and
commands executed in a subshell. However this
inheritance behaviour can be turned on by using **set -o
errtrace** (or **set -E** ).[7]

One disadvantage is that exit statuses are not as uniform
(or even as meaningful) as they should be, as we
explained inChapter 5. A particular exit status need not
say anything about the nature of the error or even that
there was an error.


### DEBUG

Another fake signal, DEBUG, causes the trap code to be
executed before every statement in a function or script.[8]
This has two main uses. First is the use for humans, as a
sort of "brute force" method of tracking a certain element
of a program's state that you notice has gone awry.

For example, you notice the value of a particular variable
is running amok. The naive approach is to put in a lot of
**echo** statements to check the variable's value at several
points. The DEBUG trap makes this easier by letting you
do this:

```
function dbgtrap
{
echo " badvar
is
$badvar "
}
```
```
trap dbgtrap DEBUG
...section of code in which the problem occurs...
trap - DEBUG # turn off the DEBUG trap
```
This code will print the value of the wayward variable
before every statement between the two **trap** s.

One important point to remember when using DEBUG is
that it is not inherited by functions called from the shell in
which it is set. In other words, if your shell sets a


DEBUG trap and then calls a function, the statements
within the function will not execute the trap. There are
three ways around this. Firstly you can set a trap for
DEBUG explicitly within the function. Alternately you
can **declare** the function with the - **t** option which turns on
debug inheritance in functions and allows a function to
inherit a DEBUG trap from the caller. Lastly you can use
**set -o functrace** (or **set -T** ) which does the same thing as
**declare** but applies to all functions.[9]

The second use of the DEBUG signal is as a primitive for
implementing a _bash_ debugger. We'll look at doing just
that shortly.


### RETURN

A RETURN trap is executed each time a shell function or
a script executed with the. or **source** commands finishes
executing.

As with DEBUG, the RETURN trap is not inherited by
functions. You again have the options of setting the trap
for RETURN within the function, **declare** the function
with the - **t** option so that that function inherits the trap, or
use **set -o functrace** to turn on the inheritance for all
functions.

Here is a simple example of a RETURN trap:

```
function returntrap {
echo "A return occurred"
}
trap returntrap RETURN
function hello {
echo "hello world"
}
hello
```
When the script is executed it executes the _hello_ function
and then runs the trap:

```
$ ./returndemo
hello world
A return occurred
$
```

Notice that it didn't trap when the script itself finished.
The trap would only have run at the end of the script if
we'd **source** d the script. Normally, to trap at the exiting of
the script we'd also need to define a trap for the EXIT
signal that we looked at earlier.

In addition to these fake signals, _bash_ 3.0 added some
other features to help with writing a full-scale debugger
for _bash_. The first of these is the **extdebug** option to the
**shopt** command, which switches on certain things that
are useful for a debugger. These include:

- The -F option to **declare** displays the source
    filename and line number corresponding to each
    function name supplied as an argument.
- If the command that is run by the DEBUG trap
    returns a non-zero value, the next command is
    skipped and not executed.
- If the command run by the DEBUG trap returns a
    value of 2, and the shell is executing in a
    subroutine (a shell function or a shell script
    executed by the. or **source** commands), a call to
    **return** is simulated.

The shell also has a new option, _—debugger_ , which
switches on both the **extdebug** and **functrace**
functionality.


## Debugging Variables

_Bash_ 3.0 added some useful environment variables to aid
in writing a debugger. These include BASH_SOURCE,
which contains an array of filenames that correspond to
what is currently executing; BASH_LINENO, which is
an array of line numbers that correspond to function calls
that have been made; BASH_ARGC and BASH_ARGV
array variables, the first holding the number of
parameters in each frame and the second the parameters
themselves.

We'll now look at writing a debugger, although we'll keep
things simple and avoid using these variables. This also
means the debugger will work with earlier versions of
_bash_.

[1]Actually, if you are really concerned about efficiency,

there are shell code compilers on the market; they convert
shell scripts to C code that often runs quite a bit faster.

[2]In versions of _bash_ prior to 2.0, **LINENO** won't give

you the current line in a function. **LINENO** , instead,
gives an approximation of the number of simple
commands executed so far in the current function.


[3]We should admit that if you had turned on the **nounset**

option at the top of this script, the shell would have
flagged this error.

[6]You can use this signal only for the exiting of a script.

Functions don't generate the EXIT signal, as they are part
of the current shell invocation.

[7]Inheritance of the ERR trap is not available in versions

of _bash_ prior to 3.0.

[8]Warning: the **DEBUG** trap was run _after_ statements in

versions of _bash_ prior to 2.05b. The debugger in this
chapter has been written for the current version of _bash_
where the trap is run before each statement.

[9]Inheritance of the DEBUG trap, **declare -t** , **set -o**

**functrace** , and **set -T** are not available in _bash_ prior to
version 3.0.


# A bash Debugger

In this section we'll develop a very basic debugger for
_bash_ .[10]Most debuggers have numerous sophisticated
features that help a programmer in dissecting a program,
but just about all of them include the ability to step
through a running program, stop it at selected places, and
examine the values of variables. These simple features
are what we will concentrate on providing in our
debugger. Specifically, we'll provide the ability to:

- Specify places in the program at which to stop
    execution. These are called _breakpoints_.
- Execute a specified number of statements in the
    program. This is called _stepping_.
- Examine and change the state of the program
    during its execution. This includes being able to
    print out the values of variables and change them
    when the program is stopped at a breakpoint or
    after stepping.
- Print out the source code we are debugging along
    with indications of where breakpoints are and
    what line in the program we are currently
    executing.


- Provide the debugging capability without having
    to change the original source code of the program
    we wish to debug in any way.

As you will see, the capability to do all of these things
(and more) is easily provided by the constructs and
methods we have seen in previous chapters.

## Structure of the Debugger

The _bashdb_ debugger works by taking a shell script and
turning it into a debugger for itself. It does this by
concatenating debugger functionality and the target
script, which we'll call the guinea pig script, and storing it
in another file that then gets executed. The process is
transparent to users—they will be unaware that the code
that is executing is actually a modified copy of their
script.

The _bash_ debugger has three main sections: the _driver_ ,
the _preamble_ , and the _debugger functions_.

### The driver script

The driver script is responsible for setting everything up.
It is a script called _bashdb_ and looks like this:

```
# bashdb - a bash debugger
# Driver Script: concatenates the preamble and the target script
```

```
# and then executes the new script.
```
```
echo 'bash Debugger version 1.0'
```
```
_dbname=${0##*/}
```
```
if (( $# < 1 )) ; then
echo "$_dbname: Usage: $_dbname filename" >&2
exit 1
fi
```
```
_guineapig=$1
```
```
if [! -r $1 ]; then
echo "$_dbname: Cannot read file '$_guineapig'." >&2
exit 1
fi
```
```
shift
```
```
_tmpdir=/tmp
_libdir=.
_debugfile=$_tmpdir/bashdb.$$ # temporary file for script that is
being debugged
cat $_libdir/bashdb.pre $_guineapig > $_debugfile
exec bash $_debugfile $_guineapig $_tmpdir $_libdir "$@"
```
_bashdb_ takes as the first argument the name of guinea pig
file. Any subsequent arguments are passed on to the
guinea pig as its positional parameters.

If no arguments are given, _bashdb_ prints out a usage line
and exits with an error status. Otherwise, it checks to see
if the file exists. If it doesn't, exist then _bashdb_ prints a
message and exits with an error status. If all is in order,
_bashdb_ constructs a temporary file in the way we saw in


the last chapter. If you don't have (or don't have access to)
_/tmp_ on your system, then you can substitute a different
directory for **_tmpdir** .[11] The variable **_libdir** is the
name of the directory that contains files needed by
_bashdb_ ( _bashdb.pre_ and _bashdb.fns_ ). If you are installing
_bashdb_ on your system for everyone to use, you might
want to place them in _/usr/lib_.

The **cat** statement builds the modified copy of the guinea
pig file: it contains the script found in _bashdb.pre_ (which
we'll look at shortly) followed by a copy of the guinea
pig.


### exec

The last line runs the newly created script with **exec** , a
statement we haven't discussed yet. We've chosen to wait
until now to introduce it because—as we think you'll
agree—it can be dangerous. **exec** takes its arguments as a
command line and runs the command in place of the
current program, in the same process. In other words, a
shell that runs **exec** will _terminate immediately_ and be
replaced by **exec** 's arguments.[12]

In our script, **exec** just runs the newly constructed shell
script, i.e., the guinea pig with its debugger, in another
shell. It passes the new script three arguments—the name
of the original guinea pig file ( **$_guineapig** ), the name of
the temporary directory ( **$_tmpdir** ), and the name of the
library directory ( **$_libdir** )—followed by the user's
positional parameters, if any.


## The Preamble

Now we'll look at the code that gets prepended to the
guinea pig script; we call this the preamble. It's kept in
the file _bashdb.pre_ and looks like this:

```
# bashdb preamble
# This file gets prepended to the shell script being debugged.
# Arguments:
# $1 = the name of the original guinea pig script
# $2 = the directory where temporary files are stored
# $3 = the directory where bashdb.pre and bashdb.fns are stored
```
```
_debugfile=$0
_guineapig=$1
```
```
_tmpdir=$2
_libdir=$3
```
```
shift 3
```
```
source $_libdir/bashdb.fns
_linebp=
let _trace=0
let _i=1
```
```
while read; do
_lines[$_i]=$REPLY
let _i=$_i+1
done < $_guineapig
```
```
trap _cleanup EXIT
```

```
let _steps=1
trap '_steptrap $(( $LINENO -29 ))' DEBUG
```
The first few lines save the three fixed arguments in
variables and shift them out of the way, so that the
positional parameters (if any) are those that the user
supplied on the command line as arguments to the guinea
pig. Then, the preamble reads in another file, _bashdb.fns_ ,
which contains all of the functions necessary for the
operation of the debugger itself. We put this code in a
separate file to minimize the size of the temporary file.
We'll examine _bashdb.fns_ shortly.

Next, _bashdb.pre_ initializes a breakpoint array to empty
and execution tracing to off (see the following
discussion), then reads the original guinea pig script into
an array of lines. We need the source lines from the
original script for two reasons: to allow the debugger to
print out the script showing where the breakpoints are,
and to print out the lines of code as they execute if tracing
is turned on. You'll notice that we assign the script lines
to **_lines** from the environment variable **$REPLY** rather
than reading them into the array directly. This is because
**$REPLY** preserves any leading whitespace in the lines,
i.e., it preserves the indentation and layout of the original
script.

The last five lines of code set up the conditions necessary
for the debugger to begin working. The first **trap**
command sets up a clean-up routine that runs when the
fake signal EXIT occurs. The clean-up routine, normally
called when the debugger and guinea pig script finish,


just erases the temporary file. The next line sets the
variable **_steps** to 1 so that when the debugger is first
entered, it will stop after the first line.

The next line sets up the routine **_steptrap** to run when
the fake signal DEBUG occurs.

The built-in variable **LINENO** , which we saw earlier in
the chapter, is used to provide line numbers in the
debugger. However, if we just used **LINENO** as is, we'd
get line numbers above 30 because **LINENO** would be
including the lines in the preamble. To get around this,
we can pass **LINENO** minus the number of lines in the
preamble to the trap.[13]


## Debugger Functions

The function **_steptrap** is the entry point into the
debugger; it is defined in the file _bashdb.fns_. Here is
**_steptrap** :

```
# After each line of the test script is executed the shell traps to
# this function.
```
```
function _steptrap
{
_curline=$1 # the number of the line that just ran
```
```
(( $_trace )) && _msg "$PS4 line $_curline: ${_lines[$_curline]}"
```
```
if (( $_steps >= 0 )); then
let _steps="$_steps - 1"
fi
```
```
# First check to see if a line number breakpoint was reached.
# If it was, then enter the debugger.
if _at_linenumbp ; then
_msg "Reached breakpoint at line $_curline"
_cmdloop
```
```
# It wasn't, so check whether a break condition exists and is true.
# If it is, then enter the debugger.
elif [ -n "$_brcond" ] && eval $_brcond; then
_msg "Break condition $_brcond true at line $_curline"
_cmdloop
```
```
# It wasn't, so check if we are in step mode and the number of steps
# is up. If it is then enter the debugger.
```

```
elif (( $_steps == 0 )); then
_msg "Stopped at line $_curline"
_cmdloop
fi
}
```
**_steptrap** starts by setting **_curline** to the number of the
guinea pig line that just ran. If execution tracing is on, it
prints the PS4 execution trace prompt (like the shell's
**xtrace** mode), line number, and line of code itself. It then
decrements the number of steps if the number of steps
still left is greater than or equal to zero.

Then it does one of two things: it enters the debugger via
**_cmdloop** , or it returns so the shell can execute the next
statement. It chooses the former if a breakpoint or break
condition has been reached, or if the user stepped into this
statement.

### Commands

We will explain shortly how **_steptrap** determines these
things; now we will look at **_cmdloop**. It's a simple
combination of the case statements we saw inChapter 5,
and the calculator loop we saw in the previous chapter.

```
# The Debugger Command Loop
```
```
function _cmdloop {
local cmd args
```
```
while read -e -p "bashdb> " cmd args; do
case $cmd in
```

```
\? | h ) _menu ;; # print command menu
bc ) _setbc $args ;; # set a break condition
bp ) _setbp $args ;; # set a breakpoint at the given
# line
cb ) _clearbp $args ;; # clear one or all breakpoints
ds ) _displayscript ;; # list the script and show the
# breakpoints
g ) return ;; # "go": start/resume execution of
# the script
q ) exit ;; # quit
```
```
s ) let _steps=${args:-1} # single step N times
# (default = 1)
return ;;
x ) _xtrace ;; # toggle execution trace
!* ) eval ${cmd#!} $args ;; # pass to the shell
* ) _msg "Invalid command: '$cmd'" ;;
esac
done
}
```
At each iteration, **_cmdloop** prints a prompt, reads a
command, and processes it. We use **read -e** so that the
user can take advantage of the _readline_ command-line
editing. The commands are all one- or two-letter
abbreviations; quick for typing, but terse in the UNIX
style.[14]

Table 9-3summarizes the debugger commands.

**Table 9-3. bashdb commands**


**Command Action**

**bp** _N_ Set breakpoint at line _N_

bp List breakpoints and break condition

**bc** _string_ Set break condition to _string_

bc Clear break condition

**cb** _N_ Clear breakpoint at line _N_

cb Clear all breakpoints

ds Display the test script and breakpoints

g Start/resume execution

**s** [ _N_ ] Execute _N_ statements (default 1)


```
Command Action
```
```
x Toggle execution trace on/off
```
```
h ,? Print the help menu
```
```
! string Pass string to a shell
```
```
q Quit
```
Before looking at the individual commands, it is
important that you understand how control passes through
**_steptrap** , the command loop, and the guinea pig.

**_steptrap** runs after every statement in the guinea pig as
a result of the trap on DEBUG in the preamble. If a
breakpoint has been reached or the user previously typed
in a step command(s), **_steptrap** calls the command loop.
In doing so, it effectively "interrupts" the shell that is
running the guinea pig to hand control over to the user.

The user can invoke debugger commands as well as shell
commands that run in the same shell as the guinea pig.
This means that you can use shell commands to check
values of variables, signal traps, and any other


information local to the script being debugged. The
command loop continues to run, and the user stays in
control, until he types **g** , **q** , or **s**. We'll now look in detail
at what happens in each of these cases.

Typing **g** has the effect of running the guinea pig
uninterrupted until it finishes or hits a breakpoint. It
simply exits the command loop and returns to **_steptrap** ,
which exits as well. The shell then regains control and
runs the next statement in the guinea pig script. Another
DEBUG signal occurs and the shell traps to **_steptrap**
again. If there are no breakpoints then **_steptrap** will just
exit. This process will repeat until a breakpoint is reached
or the guinea pig finishes.

The **q** command calls the function **_cleanup** , which
erases the temporary file and exits the program.


### Stepping

When the user types **s** , the command loop code sets the
variable **_steps** to the number of steps the user wants to
execute, i.e., to the argument given. Assume at first that
the user omits the argument, meaning that **_steps** is set to

1. Then the command loop exits and returns control to
**_steptrap** , which (as above) exits and hands control back
to the shell. The shell runs the next statement and returns
to **_steptrap** , which then decrements **_steps** to 0. Then
the second **elif** conditional becomes true because **_steps**
is 0 and prints a "stopped" message and then calls the
command loop.

Now assume that the user supplies an argument to **s** , say

3. **_steps** is set to 3. Then the following happens:
    1. After the next statement runs, **_steptrap** is called
       again. It enters the first **if** clause, since **_steps** is
       greater than 0. **_steptrap** decrements **_steps** to 2
       and exits, returning control to the shell.
    2. This process repeats, another step in the guinea
       pig is run, and **_steps** becomes 1.
    3. A third statement is run and we're back in
       **_steptrap**. **_steps** is decremented to 0, the
       second **elif** clause is run, and **_steptrap** breaks
       out to the command loop again.


The overall effect is that the three steps run and then the
debugger takes over again.

All of the other debugger commands cause the shell to
stay in the command loop, meaning that the user prolongs
the "interruption" of the shell.


### Breakpoints

Now we'll examine the breakpoint-related commands and
the breakpoint mechanism in general. The **bp** command
calls the function **_setbp** , which can do two things,
depending on whether an argument is supplied or not.
Here is the code for **_setbp** :

```
# Set a breakpoint at the given line number or list breakpoints
function _setbp
{
local i
```
```
if [ -z "$1" ]; then
_listbp
elif [ $(echo $1 | grep '^[0-9]*') ]; then
if [ -n "${_lines[$1]}" ]; then
_linebp=($(echo $( (for i in ${_linebp[*]} $1; do
echo $i; done) | sort -n) ))
_msg "Breakpoint set at line $1"
else
_msg "Breakpoints can only be set on non-blank lines"
fi
else
_msg "Please specify a numeric line number"
fi
}
```
If no argument is supplied, **_setbp** calls **_listbp** , which
prints the line numbers that have breakpoints set. If
anything other than a number is supplied as an argument,
an error message is printed and control returns to the
command loop. Providing a number as the argument


allows us to set a breakpoint; however, we have to do
another test before doing so.

What happens if the user decides to set a breakpoint at a
nonsensical point: a blank line, or at line 1,000 of a
10-line program? If the breakpoint is set well beyond the
end of the program, it will never be reached and will
cause no problem. If, however, a breakpoint is set at a
blank line, it will cause problems. The reason is that the
DEBUG trap only occurs after each executed _simple
command_ in a script, not each line. Blank lines never
generate the DEBUG signal. The user could set a
breakpoint on a blank line, in which case continuing
execution with the **g** command would never break back
out to the debugger.

We can fix both of these problems by making sure that
breakpoints are set only on lines with text.[15] After
making the tests, we can add the breakpoint to the
breakpoint array, **_linebp**. This is a little more complex
than it sounds. In order to make the code in other sections
of the debugger simpler, we should maintain a sorted
array of breakpoints. To do this, we echo all of the line
numbers currently in the array, along with the new
number, in a subshell and pipe them into the UNIX **sort**
command. **sort -n** sorts a list into numerically ascending
order. The result of this is a list of ordered numbers which
we then assign back to the **_linebp** array with a
compound assignment.


To complement the user's ability to add breakpoints, we
also allow the user to delete them. The **cb** command
allows the user to clear single breakpoints or all
breakpoints, depending on whether a line number
argument is supplied or not. For example, **cb 12** clears a
breakpoint at line 12 (if a breakpoint was set at that line).
**cb** on its own would clear all of the breakpoints that have
been set. It is useful to look briefly at how this works;
here is the code for the function that is called with the **cb**
command, **_clearbp** :

```
function _clearbp
{
local i
```
```
if [ -z "$1" ]; then
unset _linebp[*]
_msg "All breakpoints have been cleared"
elif [ $(echo $1 | grep '^[0-9]*') ]; then
_linebp=($(echo $(for i in ${_linebp[*]}; do
if (( $1 != $i )); then echo $i; fi; done) ))
_msg "Breakpoint cleared at line $1"
else
_msg "Please specify a numeric line number"
fi
}
```
The structure of the code is similar to that used for setting
the breakpoints. If no argument was supplied to the
command, the breakpoint array is unset, effectively
deleting all the breakpoints. If an argument was supplied
and is not a number, we print out an error message and
exit.


A numeric argument to the **cb** command means the code
has to search the list of breakpoints and delete the
specified one. We can easily make the deletion by
following a procedure similar to the one we used when
we added a breakpoint in **_setbp**. We execute a loop in a
subshell, printing out the line numbers in the breakpoints
list and ignoring any that match the provided argument.
The echoed values once again form a compound
statement, which can then be assigned to an array
variable.[16]

The function **_at_linenumbp** is called by **_steptrap** after
every statement; it checks whether the shell has arrived at
a line number breakpoint. The code for the function is:

```
# See if this line number has a breakpoint
function _at_linenumbp
{
local i=0
```
```
if [ "$_linebp" ]; then
while (( $i < ${#_linebp[@]} )); do
if (( ${_linebp[$i]} == $_curline )); then
return 0
fi
let i=$i+1
done
fi
return 1
}
```
The function simply loops through the breakpoint array
and checks the current line number against each one. If a
match is found, it returns **true** (i.e., returns 0). Otherwise,


it continues looping, looking for a match until the end of
the array is reached. It then returns **false**.

It is possible to find out exactly what line the debugger is
up to and where the breakpoints have been set in the
guinea pig by using the **ds** command. We'll see an
example of the output later, when we run a sample
_bashdb_ debugging session. The code for this function is
fairly straightforward:

```
# Print out the shell script and mark the location of breakpoints
# and the current line
function _displayscript
{
local i=1 j=0 bp cl
```
```
( while (( $i < ${#_lines[@]} )); do
if [ ${_linebp[$j]} ] && (( ${_linebp[$j]} == $i )); then
bp='*'
let j=$j+1
else
bp=' '
fi
```
```
if (( $_curline == $i )); then
cl=">"
else
cl=" "
fi
```
```
echo "$i:$bp $cl ${_lines[$i]}"
let i=$i+1
done
) | more
}
```

This function contains a subshell, the output of which is
piped to the UNIX **more** command. We have done this
for user-friendly reasons; a long script would scroll up the
screen quickly and the users may not have displays that
allow them to scroll back to previous pages of screen
output. **more** displays one screenful of output at a time.

The core of the subshell code loops through the lines of
the guinea pig script. It first tests to see if the line it is
about to display is in the array of breakpoints. If it is, a
breakpoint character ( ***** ) is set and the local variable **j** is
incremented. **j** was initialized to 0 at the beginning of the
function; it contains the current breakpoint that we are up
to. It should now be apparent why we went to the trouble
of sorting the breakpoints in **_setbp** : both the line
numbers and the breakpoint numbers increment
sequentially, and once we pass a line number that has a
breakpoint and find it in the breakpoint array, we know
that future breakpoints in the script must be further on in
the array. If the breakpoint array contained line numbers
in a random order, we'd have to search the entire array to
find out if a line number was in the array or not.

The core of the subshell code then checks to see if the
current line and the line it is about to display are the
same. If they are, a "current line" character (>) is set. The
current displayed line number (stored in **i** ), breakpoint
character, current line character, and script line are then
printed out.


We think you'll agree that the added complexity in the
handling of breakpoints is well worth it. Being able to
display the script and the location of breakpoints is an
important feature in any debugger.


### Break conditions

_bashdb_ provides another method of breaking out of the
guinea pig script: the _break condition_. This is a string that
the user can specify that is evaluated as a command; if it
is true (i.e., returns exit status 0), the debugger enters the
command loop.

Since the break condition can be any line of shell code,
there's a lot of flexibility in what can be tested. For
example, you can break when a variable reaches a certain
value—e.g., **(( $x < 0 ))—** or when a particular piece of
text has been written to a file ( **grep** _string file_ ). You will
probably think of all kinds of uses for this feature.[17]To
set a break condition, type **bc** _string_. To remove it, type
**bc** without arguments—this installs the null string, which
is ignored.

**_steptrap** evaluates the break condition **$_brcond** only if
it's not null. If the break condition evaluates to 0, then the
**if** clause is true and, once again, **_steptrap** calls the
command loop.


### Execution tracing

The final feature of the debugger is _execution tracing_ ,
available with the **x** command.

The function **_xtrace** "toggles" execution tracing simply
by assigning to the variable **_trace** the logical "not" of its
current value, so that it alternates between 0 (off) and 1
(on). The preamble initializes it to 0.


### Debugger limitations

We have kept _bashdb_ reasonably simple so that you can
see the fundamentals of building a shell script debugger.
Although it contains some useful features and is designed
to be a real tool, not just a scripting example, it has some
important limitations. Some are described in the list that
follows.

1. Debuggers tend to run programs slower than if
    they were executed on their own. _bashdb_ is no
    exception. Depending upon the script you use it
    on, you'll find the debugger runs everything
    anywhere from 8 to 30 times more slowly. This
    isn't so much of a problem if you are stepping
    through a script in small increments, but bear it in
    mind if you have, say, initialization code with
    large looping constructs.
2. The debugger will not "step down" into shell
    scripts that are called from the guinea pig. To do
    this, you'd have to edit your guinea pig script and
    change a call to scriptname to **bashdb**
    scriptname.
3. Similarly, nested subshells are treated as one
    gigantic statement; you cannot step down into
    them at all.


4. The guinea pig itself should not trap on the fake
    signals DEBUG and EXIT; otherwise the
    debugger won't work.
5. Command error handling could be significantly
    improved.

Many of these are not insurmountable and you can
experiment with solving them yourself; see the exercises
at the end of this chapter.

The debugger from an earlier version of this book helped
inspire a more comprehensive _bash_ debugger maintained
by Rocky Bernstein, which you can find at the Bash
Debugger Project, _[http://bashdb.sourceforge.net/](http://bashdb.sourceforge.net/)_.


## A Sample bashdb Session

Now we'll show a transcript of an actual session with
_bashdb_ , in which the guinea pig is the solution to Task
6-1, the script _ndu_. Here is the transcript of the debugging
session:

```
[bash]$ bashdb ndu
bash Debugger version 1.0
Stopped at line 0
bashdb> ds
1: for dir in ${*:-.}; do
2: if [ -e $dir ]; then
3: result=$(du -s $dir | cut -f 1)
4: let total=$result*1024
5:
6: echo -n "Total for $dir = $total bytes"
7:
8: if [ $total -ge 1048576 ]; then
9: echo " ($((total/1048576)) Mb)"
10: elif [ $total -ge 1024 ]; then
11: echo " ($((total/1024)) Kb)"
12: fi
13: fi
14: done
bashdb> s
Stopped at line 2
bashdb> bp 4
Breakpoint set at line 4
bashdb> bp 8
Breakpoint set at line 8
bashdb> bp 11
```

Breakpoint set at line 11
bashdb> **ds**
1: for dir in ${*:-.}; do
2: > if [ -e $dir ]; then
3: result=$(du -s $dir | cut -f 1)
4:* let total=$result*1024
5:
6: echo -n "Total for $dir = $total bytes"
7:
8:* if [ $total -ge 1048576 ]; then
9: echo " ($((total/1048576)) Mb)"
10: elif [ $total -ge 1024 ]; then
11:* echo " ($((total/1024)) Kb)"
12: fi
13: fi
14: done
bashdb> **g**
Reached breakpoint at line 4
bashdb> **!echo $total**
6840032
bashdb> _cb 8_
Breakpoint cleared at line 8
bashdb> **ds**
1: for dir in ${*:-.}; do
2: if [ -e $dir ]; then
3: result=$(du -s $dir | cut -f 1)
4:* > let total=$result*1024
5:
6: echo -n "Total for $dir = $total bytes"
7:
8: if [ $total -ge 1048576 ]; then
9: echo " ($((total/1048576)) Mb)"
10: elif [ $total -ge 1024 ]; then
11:* echo " ($((total/1024)) Kb)"
12: fi
13: fi
14: done


```
bashdb> bp
Breakpoints at lines: 4 11
Break on condition:
```
```
bashdb> !total=5600
bashdb> g
Total for. = 5600 bytes (5 Kb)
Reached breakpoint at line 11
bashdb> cb
All breakpoints have been cleared
bashdb> ds
1: for dir in ${*:-.}; do
2: if [ -e $dir ]; then
3: result=$(du -s $dir | cut -f 1)
4: let total=$result*1024
5:
6: echo -n "Total for $dir = $total bytes"
7:
8: if [ $total -ge 1048576 ]; then
9: echo " ($((total/1048576)) Mb)"
10: elif [ $total -ge 1024 ]; then
11: > echo " ($((total/1024)) Kb)"
12: fi
13: fi
14: done
bashdb> g
[bash]$
```
First, we display the script with **ds** and then perform a
step, taking execution to line 2 of _ndu_. We then set
breakpoints at lines 4, 8, and 11 and display the script
again. This time the breakpoints are clearly marked by
asterisks ( ***** ). The right angle bracket (>) indicates that
line 2 was the most recent line executed.


Next, we continue execution of the script that breaks at
line 4. We print out the value of **total** now and decide to
clear the breakpoint at line 8. Displaying the script
confirms that the breakpoint at line 8 is indeed gone. We
can also use the **bp** command, and it too shows that the
only breakpoints set are at lines 4 and 11.

At this stage we might decide that we want to check the
logic of the **if** branch at line 11. This requires that **$total**
be greater than or equal to 1,024, but less than 1,048,576.
As we saw previously, **$total** is very large, so we set its
value to 5,600 so that it will execute the second part of
the **if** and continue execution. The script enters that
section of the **if** correctly, prints out the value, and stops
at the breakpoint.

To finish off, we clear the breakpoints, display the script
again, and then continue execution, which exits the script.


## Exercises

We'll conclude this chapter with some suggested
enhancements to our simple debugger and a complete
listing of the debugger command source code.

1. Improve command error handling in these ways:
    1. Check that the arguments to **s** are valid
       numbers and print an appropriate error
       message if they aren't.
    2. Check that a breakpoint actually exists
       before clearing it and warn the user if the
       line doesn't have a breakpoint.
    3. Any other error handling that you can
       think of.
2. Add code to remove duplicate breakpoints (more
    than one breakpoint on one line).
3. Enhance the **cb** command so that the user can
    specify more than one breakpoint to be cleared at
    a time.
4. Implement an option that causes a break into the
    debugger whenever a command exits with
    non-zero status:


1. Implement it as the command-line option
    **-e**.
2. Implement it as the debugger command **e**
    to toggle it on and off. (Hint: when you
    enter **_steptrap** , **$?** is still the exit status
    of the last command that ran.)
5. Implement a command that prints out the status
of the debugger: whether execution trace is on/
off, error exit is on/off, and the number of the last
line to be executed. In addition, move the
functionality for displaying the breakpoints from
**bp** to the new option.
6. Add support for multiple break conditions, so
that _bashdb_ stops execution whenever one of
them becomes true and prints a message
indicating which one became true. Do this by
storing the break conditions in an array. Try to
make this as efficient as possible, since the
checking will take place after every statement.
7. Add the ability to watch variables.
1. Add a command **aw** that takes a variable
name as an argument and adds it to a list
of variables to watch. Any watched
variables are printed out when execution
trace is toggled on.


2. Add another command **cw** that, without
    an argument, removes all of the variables
    from the watch list. With an argument, it
    removes the specified variable.
8. Although placing an underscore at the start of the
debugger identifiers will avoid name clashes in
most cases, think of ways to automatically detect
name clashes with the guinea pig script and how
to get around this problem. (Hint: you could
rename the clashing names in the guinea pig
script at the point where it gets combined with
the preamble and placed in the temporary file.)
9. Add any other features you can think of.

Finally, here is a complete source listing of the debugger
function file _bashdb.fns_ :

```
# After each line of the test script is executed the shell traps to
# this function.
```
```
function _steptrap
{
_curline=$1 # the number of the line that just ran
```
```
(( $_trace )) && _msg "$PS4 line $_curline: ${_lines[$_curline]}"
```
```
if (( $_steps >= 0 )); then
let _steps="$_steps - 1"
fi
```
```
# First check to see if a line number breakpoint was reached.
# If it was, then enter the debugger.
```

```
if _at_linenumbp ; then
_msg "Reached breakpoint at line $_curline"
_cmdloop
```
```
# It wasn't, so check whether a break condition exists and is true.
# If it is, then enter the debugger
elif [ -n "$_brcond" ] && eval $_brcond; then
_msg "Break condition $_brcond true at line $_curline"
_cmdloop
```
```
# It wasn't, so check if we are in step mode and the number of
# steps is up. If it is, then enter the debugger.
elif (( $_steps == 0 )); then
_msg "Stopped at line $_curline"
_cmdloop
```
fi
}

# The Debugger Command Loop

function _cmdloop {
local cmd args

```
while read -e -p "bashdb> " cmd args; do
case $cmd in
\? | h ) _menu ;; # print command menu
bc ) _setbc $args ;; # set a break condition
bp ) _setbp $args ;; # set a breakpoint at the given line
cb ) _clearbp $args ;; # clear one or all breakpoints
ds ) _displayscript ;; # list the script and show the
# breakpoints
g ) return ;; # "go": start/resume execution of
# the script
q ) exit ;; # quit
s ) let _steps=${args:-1} # single step N times (default = 1)
return ;;
```

x ) _xtrace ;; # toggle execution trace
* ) eval ${cmd#!} $args ;; # pass to the shell
* ) _msg "Invalid command: '$cmd'" ;;
esac
done
}

# See if this line number has a breakpoint
function _at_linenumbp
{
local i=0

```
# Loop through the breakpoints array and check to see if any of
# them match the current line number. If they do return true (0)
# otherwise return false.
```
if [ "$_linebp" ]; then
while (( $i < ${#_linebp[@]} )); do
if (( ${_linebp[$i]} == $_curline )); then
return 0
fi
let i=$i+1
done
fi
return 1
}

# Set a breakpoint at the given line number or list breakpoints
function _setbp
{
local i

```
# If there are no arguments call the breakpoint list function.
# Otherwise check to see if the argument was a positive number.
# If it wasn't then print an error message. If it was then check
```

```
# to see if the line number contains text. If it doesn't then
# print an error message. If it does then echo the current
# breakpoints and the new addition and pipe them to "sort" and
# assign the result back to the list of breakpoints. This results
# in keeping the breakpoints in numerical sorted order.
```
```
# Note that we can remove duplicate breakpoints here by using
# the -u option to sort which uniquifies the list.
```
if [ -z "$1" ]; then
_listbp
elif [ $(echo $1 | grep '^[0-9]*') ]; then
if [ -n "${_lines[$1]}" ]; then
_linebp=($(echo $( (for i in ${_linebp[*]} $1; do
echo $i; done) | sort -n) ))
_msg "Breakpoint set at line $1"
else
_msg "Breakpoints can only be set on non-blank lines"
fi
else
_msg "Please specify a numeric line number"
fi
}

# List breakpoints and break conditions
function _listbp
{
if [ -n "$_linebp" ]; then
_msg "Breakpoints at lines: ${_linebp[*]}"
else
_msg "No breakpoints have been set"
fi

_msg "Break on condition:"
_msg "$_brcond"
}


# Clear individual or all breakpoints
function _clearbp
{
local i bps

```
# If there are no arguments, then delete all the breakpoints.
# Otherwise, check to see if the argument was a positive number.
# If it wasn't, then print an error message. If it was, then
# echo all of the current breakpoints except the passed one
# and assign them to a local variable. (We need to do this because
# assigning them back to _linebp would keep the array at the same
# size and just move the values "back" one place, resulting in a
# duplicate value). Then destroy the old array and assign the
# elements of the local array, so we effectively recreate it,
# minus the passed breakpoint.
```
if [ -z "$1" ]; then
unset _linebp[*]
_msg "All breakpoints have been cleared"
elif [ $(echo $1 | grep '^[0-9]*') ]; then
bps=($(echo $(for i in ${_linebp[*]}; do
if (( $1 != $i )); then echo $i; fi; done) ))
unset _linebp[*]
_linebp=(${bps[*]})
_msg "Breakpoint cleared at line $1"
else
_msg "Please specify a numeric line number"
fi
}

# Set or clear a break condition
function _setbc
{
if [ -n "$*" ]; then
_brcond=$args


_msg "Break when true: $_brcond"
else
_brcond=
_msg "Break condition cleared"
fi
}

# Print out the shell script and mark the location of breakpoints
# and the current line

function _displayscript
{
local i=1 j=0 bp cl

( while (( $i < ${#_lines[@]} )); do
if [ ${_linebp[$j]} ] && (( ${_linebp[$j]} == $i )); then
bp='*'
let j=$j+1
else
bp=' '
fi
if (( $_curline == $i )); then
cl=">"
else
cl=" "
fi
echo "$i:$bp $cl ${_lines[$i]}"
let i=$i+1
done
) | more
}

# Toggle execution trace on/off
function _xtrace
{


let _trace="! $_trace"
_msg "Execution trace "
if (( $_trace )); then
_msg "on"
else
_msg "off"
fi
}

# Print the passed arguments to Standard Error
function _msg
{
echo -e "$@" >&2
}

# Print command menu
function _menu {
_msg 'bashdb commands:
bp N set breakpoint at line N
bp list breakpoints and break condition
bc string set break condition to string
bc clear break condition
cb N clear breakpoint at line N
cb clear all breakpoints
ds displays the test script and breakpoints
g start/resume execution
s [N] execute N statements (default 1)
x toggle execution trace on/off
h,? print this menu
! string passes string to a shell
q quit'
}

# Erase the temporary file before exiting


```
function _cleanup
{
rm $_debugfile 2>/dev/null
}
```
[10] Unfortunately, the debugger will not work with

versions of _bash_ prior to 2.0, because they do not
implement the DEBUG signal.

[11]All function names and variables (except those local

to functions) in _bashdb_ have names beginning with an
underscore (_), to minimize the possibility of clashes with
names in the guinea pig script.

[12] **exec** can also be used with an I/O redirector only; this

makes the redirector take effect for the remainder of the
script or login session. For example, the line **exec
2>errlog** at the top of a script directs standard error to the
file _errlog_ for the rest of the script.

[13]If you are typing or scanning in the preamble code

from this book, make sure that the last line in the file is
the call to set the trap, i.e., no blank lines should appear
after the call to **trap**.

[14] There is nothing to stop you from changing the

commands to something you find easier to remember.
There is no "official" _bash_ debugger, so feel free to
change the debugger to suit your needs.


[15]This isn't a complete solution. Certain other lines

(e.g., comments) will also be ignored by the DEBUG
trap. See the list of limitations and the exercises at the end
of this chapter.

[16] _bash_ versions 2.01 and earlier have a bug in assigning

arrays to themselves that prevents the code for **setbp** and
**clearbp** from working. In each case, you can get around
this bug by assigning **_linebp** to a local variable first,
**unset** ting it, and then assigning the local variable back to
it. Better yet, update to a more recent version of _bash_.

[17] Bear in mind that if your break condition sends

anything to standard output or standard error, you will see
it after every statement executed. Also, make sure your
break condition doesn't take a long time to run; otherwise
your script will run very, very slowly.
